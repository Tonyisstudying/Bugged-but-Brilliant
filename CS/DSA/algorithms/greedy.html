<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greedy Algorithms</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* General styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f8f0fc, #e6e6fa, #f0f8ff);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Navigation */
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3rem;
        }
        
        .back-btn {
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            background-color: #0078d7;
            color: white;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background-color: #006cc1;
            transform: translateX(-5px);
        }
        
        /* Hero section */
        .hero-section {
            background-color: #0052cc;
            padding: 4rem 2rem;
            border-radius: 15px;
            margin-bottom: 3rem;
            color: white;
            text-align: center;
        }
        
        .hero-section h1 {
            font-size: 3rem;
            margin-bottom: 1.5rem;
        }
        
        .hero-section p {
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
            font-size: 1.1rem;
        }

        /* Content Sections */
        .content-section {
            background-color: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .content-section h2 {
            color: #0052cc;
            margin-bottom: 1.5rem;
            font-size: 2rem;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.8rem;
            padding-right: 40px; /* Space for toggle icon */
        }

        .content-section p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }

        /* Code section */
        .code-section {
            background-color: white;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .code-tabs {
            display: flex;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            overflow-x: auto;
        }

        .code-tab {
            padding: 1rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .code-tab.active {
            background-color: #0078d7;
            color: white;
        }

        .code-content {
            padding: 0;
            position: relative;
        }

        .code-block {
            display: none;
            position: relative;
        }

        .code-block.active {
            display: block;
        }

        .code-block pre {
            margin: 0;
            padding: 1.5rem;
            overflow-x: auto;
            border-radius: 0;
        }

        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 4px;
            padding: 0.4rem 0.7rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* Steps section */
        .steps-section ul, .steps-section ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        .steps-section li {
            margin-bottom: 0.8rem;
            line-height: 1.6;
        }

        /* Comparison table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .comparison-table th, .comparison-table td {
            border: 1px solid #e0e0e0;
            padding: 1rem;
            text-align: left;
        }

        .comparison-table th {
            background-color: #f5f5f5;
            font-weight: 600;
        }

        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* Examples */
        .example {
            background-color: #f8f9fa;
            border-left: 4px solid #0078d7;
            padding: 1.2rem;
            margin-bottom: 1.5rem;
            border-radius: 0 8px 8px 0;
        }

        .example h3 {
            margin-bottom: 0.8rem;
            color: #0052cc;
        }

        /* Toggle functionality */
        .toggle-icon {
            position: absolute;
            top: 2.1rem;
            right: 2rem;
            cursor: pointer;
            font-size: 1.5rem;
            color: #0052cc;
            transition: transform 0.3s ease;
            z-index: 10;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: rgba(0, 82, 204, 0.1);
        }

        .toggle-icon:hover {
            background-color: rgba(0, 82, 204, 0.2);
        }

        .toggle-icon.active {
            transform: rotate(45deg);
        }

        .toggle-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .toggle-content.active {
            max-height: 2000px;
        }

        .algorithm-link {
            color: #0078d7;
            text-decoration: none;
            font-weight: 600;
        }

        .algorithm-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .hero-section h1 {
                font-size: 2.3rem;
            }
            
            .content-section h2 {
                font-size: 1.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-container">
            <a href="../algorithms.html" class="back-btn">‚Üê Back to Algorithms</a>
        </div>
        
        <div class="hero-section">
            <h1>Greedy Algorithms</h1>
            <p>An algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit.</p>
        </div>

        <div class="content-section">
            <h2>What is a Greedy Algorithm?</h2>
            <p>Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. Greedy algorithms are used for optimization problems.</p>
            <p>An optimization problem can be solved using Greedy if the problem has the following property:</p>
            <ul class="steps-section">
                <li>At every step, we can make a choice that looks best at the moment, and we get the optimal solution to the complete problem.</li>
            </ul>
        </div>

        <div class="content-section">
            <h2>Popular Greedy Algorithms</h2>
            <ul class="steps-section">
                <li><a href="#" class="algorithm-link">Fractional Knapsack</a> - Choose items with the highest value/weight ratio</li>
                <li><a href="#" class="algorithm-link">Dijkstra's algorithm</a> - Find the shortest path in a weighted graph</li>
                <li><a href="#" class="algorithm-link">Kruskal's algorithm</a> - Find the minimum spanning tree</li>
                <li><a href="#" class="algorithm-link">Huffman coding</a> - Data compression algorithm</li>
                <li><a href="#" class="algorithm-link">Prim's Algorithm</a> - Find the minimum spanning tree</li>
            </ul>
            <p>The greedy algorithms are sometimes also used to get an approximation for Hard optimization problems. For example, the <a href="#" class="algorithm-link">Traveling Salesman Problem</a> is an NP-Hard problem. A Greedy choice for this problem is to pick the nearest unvisited city from the current city at every step. These solutions don't always produce the best optimal solution but can be used to get an approximately optimal solution.</p>
        </div>

        <div class="content-section">
            <h2>Characteristics of Greedy Algorithms</h2>
            <ul class="steps-section">
                <li><strong>Simple and easy</strong> to implement.</li>
                <li>They are efficient in terms of <strong>time complexity</strong>, often providing quick solutions. Greedy Algorithms are typically preferred over Dynamic Programming for the problems where both are applied.</li>
                <li>These algorithms do not reconsider previous choices, as they make decisions based on <strong>current information without looking ahead</strong>.</li>
            </ul>
        </div>

        <div class="content-section">
            <h2>How does the Greedy Algorithm work?</h2>
            <ol class="steps-section">
                <li>Start with the <strong>initial state</strong> of the problem. This is the starting point from where you begin making choices.</li>
                <li>Evaluate <strong>all possible choices</strong> you can make from the current state. Consider all the options available at that specific moment.</li>
                <li>Choose the option that seems best at that moment, regardless of future consequences. This is the "greedy" part - <strong>you take the best option available now</strong>, even if it might not be the best in the long run.</li>
                <li>Move to the new state based on your chosen option. This becomes your <strong>new starting point</strong> for the next iteration.</li>
                <li>Repeat steps 2-4 until you reach the goal state or no further progress is possible. Keep making the best local choices until you reach the end of the problem or get stuck.</li>
            </ol>
        </div>

        <div class="content-section">
            <h2>When do Greedy Algorithms work?</h2>
            <p>However, it's important to note that not all problems are suitable for greedy algorithms. They work best when the problem exhibits the following properties:</p>
            <ul class="steps-section">
                <li><strong>Greedy Choice Property:</strong> The optimal solution can be constructed by making the best local choice at each step.</li>
                <li><strong>Optimal Substructure:</strong> The optimal solution to the problem contains the optimal solutions to its subproblems.</li>
            </ul>
        </div>

        <div class="content-section">
            <h2>How to Identify Greedy Problems</h2>
            <p>There are two major ways to detect greedy problems:</p>
            <ol class="steps-section">
                <li><strong>Can we break the problem into smaller parts?</strong> If so, and solving those parts helps us solve the main problem, it probably would be solved using greedy approach. For example - In activity selection problem, once we have selected an activity then remaining subproblem is to choose those activities that start after the selected activity.</li>
                <li><strong>Will choosing the best option at each step lead to the best overall solution?</strong> If yes, then a greedy algorithm could be a good choice. For example - In Dijkstra's shortest path algorithm, choosing the minimum-cost edge at each step guarantees the shortest path.</li>
            </ol>
        </div>

        <div class="content-section">
            <h2>Comparison: Greedy vs Dynamic Programming</h2>
            <div class="toggle-icon" onclick="toggleContent('comparison')">
                <i class="fas fa-plus"></i>
            </div>
            <div class="toggle-content" id="comparison">
                <div class="comparison-table-container">
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>Greedy Algorithms</th>
                                <th>Dynamic Programming</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Decision Making</td>
                                <td>Makes locally optimal choices at each step</td>
                                <td>Considers all possible decisions and their outcomes</td>
                            </tr>
                            <tr>
                                <td>Problem Solving Approach</td>
                                <td>Top-down (starts with the given problem and directly solves it)</td>
                                <td>Bottom-up (breaks problem into subproblems and builds solution)</td>
                            </tr>
                            <tr>
                                <td>Time Complexity</td>
                                <td>Generally faster (often O(n log n) or better)</td>
                                <td>Usually slower (often O(n¬≤) or more)</td>
                            </tr>
                            <tr>
                                <td>Space Complexity</td>
                                <td>Low (doesn't need to store subproblem solutions)</td>
                                <td>High (requires storage for all subproblem solutions)</td>
                            </tr>
                            <tr>
                                <td>Problem Requirements</td>
                                <td>Greedy Choice Property + Optimal Substructure</td>
                                <td>Optimal Substructure + Overlapping Subproblems</td>
                            </tr>
                            <tr>
                                <td>Solution Guarantee</td>
                                <td>Not always optimal (problem-specific)</td>
                                <td>Always optimal if applied correctly</td>
                            </tr>
                            <tr>
                                <td>Reconsideration</td>
                                <td>Never reconsiders choices once made</td>
                                <td>Evaluates all possible choices before making decision</td>
                            </tr>
                            <tr>
                                <td>Implementation</td>
                                <td>Typically easier to implement</td>
                                <td>Generally more complex implementation</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Key Differences</h3>
                <ol class="steps-section">
                    <li><strong>Decision-making approach:</strong> 
                        <ul>
                            <li>Greedy algorithm: Makes the locally optimal choice at each step without looking ahead</li>
                            <li>Dynamic Programming: Evaluates all possible choices to find the globally optimal solution</li>
                        </ul>
                    </li>
                    <li><strong>Problem characteristics:</strong> 
                        <ul>
                            <li>Greedy algorithm works when the problem has Greedy Choice Property and Optimal Substructure</li>
                            <li>Dynamic programming works when a problem has Optimal Substructure but it also requires Overlapping Subproblems</li>
                        </ul>
                    </li>
                    <li><strong>Solution approach:</strong> 
                        <ul>
                            <li>In greedy algorithm each local decision leads to an optimal solution for the entire problem</li>
                            <li>In dynamic programming solution to the main problem depends on the overlapping subproblems</li>
                        </ul>
                    </li>
                </ol>

                <h3>Example Comparison: Fractional vs. 0/1 Knapsack</h3>
                <div class="example">
                    <h4>Fractional Knapsack (Greedy)</h4>
                    <p>Items can be broken into smaller pieces, so we can take fractions of items.</p>
                    <p><strong>Approach:</strong> Sort items by value-to-weight ratio and take as much as possible of the item with the highest ratio, then the next highest, and so on.</p>
                    <p><strong>Why Greedy works:</strong> Taking the highest value-per-weight item first always gives the optimal solution because we can take fractions.</p>
                </div>

                <div class="example">
                    <h4>0/1 Knapsack (Dynamic Programming)</h4>
                    <p>Items cannot be broken, so we either take an item completely or don't take it at all.</p>
                    <p><strong>Approach:</strong> Create a table to store results of subproblems. For each item, we have two choices: take it or leave it.</p>
                    <p><strong>Why DP is needed:</strong> Greedy approach doesn't work because taking the highest value-per-weight item first might not leave enough capacity for a better combination of items.</p>
                </div>

                <h3>When to Choose Which Approach</h3>
                <p>Choose <strong>Greedy</strong> when:</p>
                <ul class="steps-section">
                    <li>The problem has the greedy choice property</li>
                    <li>A locally optimal choice leads to a globally optimal solution</li>
                    <li>You need a fast solution even if it's not always optimal</li>
                    <li>Problem examples: Huffman coding, Dijkstra's algorithm, Activity Selection</li>
                </ul>

                <p>Choose <strong>Dynamic Programming</strong> when:</p>
                <ul class="steps-section">
                    <li>The problem has overlapping subproblems</li>
                    <li>The problem requires considering all possible choices to find the optimal solution</li>
                    <li>You need the guaranteed optimal solution</li>
                    <li>Problem examples: 0/1 Knapsack, Longest Common Subsequence, Matrix Chain Multiplication</li>
                </ul>
            </div>
        </div>

        <div class="code-section">
            <div class="code-tabs">
                <div class="code-tab active" onclick="switchTab(this, 'cpp')">C++</div>
                <div class="code-tab" onclick="switchTab(this, 'java')">Java</div>
                <div class="code-tab" onclick="switchTab(this, 'python')">Python</div>
                <div class="code-tab" onclick="switchTab(this, 'javascript')">JavaScript</div>
            </div>
            <div class="code-content">
                <div class="code-block active" id="cpp">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-cpp">// C++ implementation of Fractional Knapsack
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Structure for an item which stores weight and value
struct Item {
    int value, weight;
    
    // Constructor
    Item(int value, int weight) : value(value), weight(weight) {}
};

// Comparison function to sort items according to value/weight ratio
bool cmp(struct Item a, struct Item b) {
    double r1 = (double)a.value / a.weight;
    double r2 = (double)b.value / b.weight;
    return r1 > r2;
}

// Main greedy function to solve problem
double fractionalKnapsack(int W, struct Item arr[], int n) {
    // Sort items by value/weight ratio
    sort(arr, arr + n, cmp);
    
    // Current weight in knapsack
    int curWeight = 0;
    
    // Result (value in Knapsack)
    double finalValue = 0.0;
    
    // Looping through all items
    for (int i = 0; i < n; i++) {
        // If adding Item won't overflow, add it completely
        if (curWeight + arr[i].weight <= W) {
            curWeight += arr[i].weight;
            finalValue += arr[i].value;
        }
        // If we can't add current Item, add fractional part of it
        else {
            int remain = W - curWeight;
            finalValue += arr[i].value * ((double)remain / arr[i].weight);
            break;
        }
    }
    
    return finalValue;
}

// Driver code
int main() {
    int W = 50;    // Weight of knapsack
    Item arr[] = { { 60, 10 }, { 100, 20 }, { 120, 30 } };
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Maximum value we can obtain = " 
         << fractionalKnapsack(W, arr, n);
    
    return 0;
}</code></pre>
                </div>
                <div class="code-block" id="java">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-java">// Java implementation of Fractional Knapsack
import java.util.*;

class Item {
    int value, weight;
    
    // Constructor
    public Item(int value, int weight) {
        this.value = value;
        this.weight = weight;
    }
}

class KnapsackGreedy {
    // Function to get maximum value
    public static double fractionalKnapsack(int W, Item[] arr, int n) {
        // Sorting items by value/weight ratio
        Arrays.sort(arr, new Comparator&lt;Item&gt;() {
            @Override
            public int compare(Item item1, Item item2) {
                double r1 = (double)item1.value / item1.weight;
                double r2 = (double)item2.value / item2.weight;
                if (r1 < r2) return 1;
                else if (r1 > r2) return -1;
                else return 0;
            }
        });
        
        // Current weight in knapsack
        int curWeight = 0;
        
        // Result (value in Knapsack)
        double finalValue = 0.0;
        
        // Looping through all items
        for (int i = 0; i < n; i++) {
            // If adding Item won't overflow, add it completely
            if (curWeight + arr[i].weight <= W) {
                curWeight += arr[i].weight;
                finalValue += arr[i].value;
            }
            // If we can't add current Item, add fractional part of it
            else {
                int remain = W - curWeight;
                finalValue += arr[i].value * ((double)remain / arr[i].weight);
                break;
            }
        }
        
        return finalValue;
    }
    
    // Driver code
    public static void main(String[] args) {
        int W = 50; // Weight of knapsack
        Item[] arr = {
            new Item(60, 10),
            new Item(100, 20),
            new Item(120, 30)
        };
        
        int n = arr.length;
        
        System.out.println("Maximum value we can obtain = " + 
                          fractionalKnapsack(W, arr, n));
    }
}</code></pre>
                </div>
                <div class="code-block" id="python">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-python"># Python implementation of Fractional Knapsack
class Item:
    def __init__(self, value, weight):
        self.value = value
        self.weight = weight
        self.ratio = value / weight

def fractional_knapsack(W, arr):
    # Sort items by value/weight ratio
    arr.sort(key=lambda x: x.ratio, reverse=True)
    
    # Current weight in knapsack
    cur_weight = 0
    
    # Result (value in Knapsack)
    final_value = 0.0
    
    # Looping through all items
    for item in arr:
        # If adding Item won't overflow, add it completely
        if cur_weight + item.weight <= W:
            cur_weight += item.weight
            final_value += item.value
        # If we can't add current Item, add fractional part of it
        else:
            remain = W - cur_weight
            final_value += item.value * (remain / item.weight)
            break
    
    return final_value

# Driver code
if __name__ == "__main__":
    W = 50  # Weight of knapsack
    arr = [
        Item(60, 10),
        Item(100, 20),
        Item(120, 30)
    ]
    
    # Function call
    max_value = fractional_knapsack(W, arr)
    print(f"Maximum value we can obtain = {max_value}")</code></pre>
                </div>
                <div class="code-block" id="javascript">
                    <button class="copy-btn" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i>
                    </button>
                    <pre><code class="language-javascript">// JavaScript implementation of Fractional Knapsack

// Class for an item which stores weight and value
class Item {
    constructor(value, weight) {
        this.value = value;
        this.weight = weight;
        this.ratio = value / weight;
    }
}

// Main greedy function to solve problem
function fractionalKnapsack(W, arr) {
    // Sort items by value/weight ratio
    arr.sort((a, b) => b.ratio - a.ratio);
    
    // Current weight in knapsack
    let curWeight = 0;
    
    // Result (value in Knapsack)
    let finalValue = 0.0;
    
    // Looping through all items
    for (let i = 0; i < arr.length; i++) {
        // If adding Item won't overflow, add it completely
        if (curWeight + arr[i].weight <= W) {
            curWeight += arr[i].weight;
            finalValue += arr[i].value;
        }
        // If we can't add current Item, add fractional part of it
        else {
            const remain = W - curWeight;
            finalValue += arr[i].value * (remain / arr[i].weight);
            break;
        }
    }
    
    return finalValue;
}

// Driver code
function main() {
    const W = 50;  // Weight of knapsack
    const arr = [
        new Item(60, 10),
        new Item(100, 20),
        new Item(120, 30)
    ];
    
    console.log("Maximum value we can obtain = " + 
                fractionalKnapsack(W, arr));
}

main();</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js"></script>
    <script>
        hljs.highlightAll();
        
        function switchTab(element, language) {
            // Remove active class from all tabs
            document.querySelectorAll('.code-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Add active class to selected tab
            element.classList.add('active');
            
            // Hide all code blocks
            document.querySelectorAll('.code-block').forEach(block => {
                block.classList.remove('active');
            });
            
            // Show selected code block
            document.getElementById(language).classList.add('active');
        }
        
        function copyCode(button) {
            const pre = button.nextElementSibling;
            const code = pre.textContent;
            
            navigator.clipboard.writeText(code).then(() => {
                const originalIcon = button.innerHTML;
                button.innerHTML = '<i class="fas fa-check"></i>';
                
                setTimeout(() => {
                    button.innerHTML = originalIcon;
                }, 2000);
            });
        }
        
        function toggleContent(id) {
            const content = document.getElementById(id);
            content.classList.toggle('active');
            
            const icon = content.previousElementSibling;
            icon.classList.toggle('active');
        }
    </script>
</body>
</html>